import java.util.regex.Matcher;
import java.util.regex.Pattern;

apply plugin: 'maven-publish'
apply plugin: 'maven'

ext.licenseFile = files("$rootDir/LICENSE.txt")

def pubVersion = '2020.2.1'

def outputsFolder = file("$buildDir/allOutputs")

def versionFile = file("$outputsFolder/version.txt")

task outputVersions() {
    description = 'Prints the versions of wpilib to a file for use by the downstream packaging project'
    group = 'Build'
    outputs.files(versionFile)

    doFirst {
        buildDir.mkdir()
        outputsFolder.mkdir()
    }

    doLast {
        versionFile.write pubVersion
    }
}

task libraryBuild() {}

build.dependsOn outputVersions

task copyAllOutputs(type: Copy) {
    destinationDir outputsFolder
}

build.dependsOn copyAllOutputs
copyAllOutputs.dependsOn outputVersions

ext.addTaskToCopyAllOutputs = { task ->
    copyAllOutputs.dependsOn task
    copyAllOutputs.inputs.file task.archivePath
    copyAllOutputs.from task.archivePath
}

def artifactGroupId = 'edu.wpi.first.wpilibStateSpace'
def baseArtifactId = 'WPILibStateSpace'
def driverZipBaseName = "_GROUP_edu_wpi_first_wpilibj_ID_${baseArtifactId}-driver_CLS"
def zipBaseName = "_GROUP_edu_wpi_first_wpilibj_ID_${baseArtifactId}-cpp_CLS"
def javaBaseName = "_GROUP_edu_wpi_first_wpilibj_ID_${baseArtifactId}-java_CLS"

task cppHeadersZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    classifier = "headers"

    from(licenseFile) {
        into '/'
    }

    from('src/main/native/include') {
        into '/'
    }
}

task cppSourceZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = zipBaseName
    classifier = "source"

    from(licenseFile) {
        into '/'
    }

    from('src/main/native/cpp') {
        into '/'
    }
}

task cppDriverHeadersZip(type: Zip) {
    destinationDirectory = outputsFolder
    archiveBaseName = driverZipBaseName
    classifier = "headers"

    from(licenseFile) {
        into '/'
    }

    from('src/main/driver/include') {
        into '/'
    }
}

build.dependsOn cppHeadersZip
addTaskToCopyAllOutputs(cppHeadersZip)
build.dependsOn cppSourceZip
addTaskToCopyAllOutputs(cppSourceZip)
build.dependsOn cppDriverHeadersZip
addTaskToCopyAllOutputs(cppDriverHeadersZip)

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

task outputJar(type: Jar, dependsOn: classes) {
    archiveBaseName = javaBaseName
    destinationDirectory = outputsFolder
    from sourceSets.main.output
}

task outputSourcesJar(type: Jar, dependsOn: classes) {
    archiveBaseName = javaBaseName
    destinationDirectory = outputsFolder
    classifier = 'sources'
    from sourceSets.main.allSource
}

task outputJavadocJar(type: Jar, dependsOn: javadoc) {
    archiveBaseName = javaBaseName
    destinationDirectory = outputsFolder
    classifier = 'javadoc'
    from javadoc.destinationDir
}

artifacts {
    archives sourcesJar
    archives javadocJar
    archives outputJar
    archives outputSourcesJar
    archives outputJavadocJar
}

addTaskToCopyAllOutputs(outputSourcesJar)
addTaskToCopyAllOutputs(outputJavadocJar)
addTaskToCopyAllOutputs(outputJar)

build.dependsOn outputSourcesJar
build.dependsOn outputJavadocJar
build.dependsOn outputJar

libraryBuild.dependsOn build

def releasesRepoUrl = "$buildDir/repos/releases"

publishing {
    repositories {
        maven {

            url = releasesRepoUrl
        }
    }
}

task cleanReleaseRepo(type: Delete) {
    delete releasesRepoUrl
}

tasks.matching {it != cleanReleaseRepo}.all {it.dependsOn cleanReleaseRepo}

model {
    publishing {
        def taskList = createComponentZipTasks($.components, ['WPILibStateSpace'], zipBaseName, Zip, project, includeStandardZipFormat)

        def driverTaskList = createComponentZipTasks($.components, ['WPILibStateSpaceDriver'], driverZipBaseName, Zip, project, includeStandardZipFormat)

        publications {
            cpp(MavenPublication) {
                taskList.each {
                    artifact it
                }
                artifact cppHeadersZip
                artifact cppSourceZip

                artifactId = "${baseArtifactId}-cpp"
                groupId artifactGroupId
                version pubVersion
            }
            driver(MavenPublication) {
                driverTaskList.each {
                    artifact it
                }
                artifact cppDriverHeadersZip

                artifactId = "${baseArtifactId}-driver"
                groupId artifactGroupId
                version pubVersion
            }

            java(MavenPublication) {
                artifact jar
                artifact sourcesJar
                artifact javadocJar

                artifactId = "${baseArtifactId}-java"
                groupId artifactGroupId
                version pubVersion
            }
        }
    }
}

//if (System.getenv()['RUN_AZURE_ARTIFACTORY_RELEASE'] != null) {
    artifactory {
        contextUrl = 'https://maven.meshnet0.com/artifactory'
        publish {
            repository {
                if(project.hasProperty('releaseRepoPublish')) {
                    repoKey = 'release'
                } else {
                    repoKey = 'gradle-dev'
                }
                username = "admin"
                password = System.getenv()['ARTIFACTORY_PUBLISH_PASSWORD']
                maven = true
            }
        }
        clientConfig.info.setBuildName('thirdparty')
    }
    publish.dependsOn artifactoryPublish
//}

def fileFinder = new FileNameFinder()

def zipFiles = files(fileFinder.getFileNames(new File(projectDir, 'build/repos/').absolutePath, '**/allOutputs/*.zip'))
def jarFiles = files(fileFinder.getFileNames(new File(projectDir, 'build/repos/').absolutePath, '**/allOutputs/*.jar'))
def allFiles = zipFiles + jarFiles

String regex = "([_M_]*)_GROUP_([^\\.]+)_ID_([^\\.]+)_CLS([^\\.]*)."
Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);

def groups = [:]

for (File it : allFiles) {

    Matcher matcher = pattern.matcher(it.name);


    if (!matcher.find()) {
        continue
    }

    def generateAll = matcher.group(1) == '_M_'

    def groupId = matcher.group(2)
    def artifactId = matcher.group(3)
    def classifier = matcher.group(4)

    if (!classifier.empty) {
        classifier = classifier.substring(1)
    }

    def group = groups[groupId]
    if (group == null) {
        group = [:]
        groups[groupId] = group
    }


    def id = group[artifactId]
    if (id == null) {
        id = []
        group[artifactId] = id
    }

    id << new Tuple(classifier, generateAll, it)

}

publishing {
    publications {
        groups.each { key, value->
            value.each { key2, value2->
                "${key}${key2}"(MavenPublication) {
                    value2.each { t->
                        artifact (t.get(2)) {
                            if (!t.get(0).empty) {
                                classifier = t.get(0)
                            }
                        }
                    }
                    groupId = key.replace('_', '.')
                    artifactId = key2
                    version = pubVersion
                }
//                if (System.getenv()['RUN_AZURE_ARTIFACTORY_RELEASE'] != null) {
                    project.artifactoryPublish {
                        publications("${key}${key2}")
                    }
//                }
            }
        }
    }
}